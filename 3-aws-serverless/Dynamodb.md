# DynamoDB

DynamoDB 是一款由 AWS(Amazon Web Services) 提供的**全托管**模式的 NoSQL 服务，AWS 进行运维。DynamoDB 可以存储文档或者键值对类型的数据，号称可以以非常低的延迟支持 **任何级别的负载**，同时有着较完善的权限管理系统。

## 为什么选择 DynamoDB:

1. 简化运维：全托管模式，减少创建、维护数据库的开销；跨区域的分区存储，数据更安全；
2. 自动扩容：数据量的增长对数据库性能没有太多影响
3. 灵活的表结构：只需要定义分区键即可正常使用，随时增加减少字段
4. 事件流：流结合 Lambda 可以非常方便的实现一些功能

## 基本内容
- 表(Table)
- 文档(Document)
- 属性(Attribute)
- **分区键**(Partition Key/Hash Key， 记为 PK，必需，数据类型必须是基本类型)
- **排序键**(Sort Key/Range Key, 记为 SK，可选)
- 数据类型：
    - 基本类型: number, string, binary, Boolean, and null
    - 文档: list, map
    - 集合: set

DynamoDB 的数据集合是一张表，表里的每一条数据就是一个文档，文档中可以存储基本类型的数据(BOOLEAN, NUMBER, STRING)或者一些复杂的数据(MAP, LIST, SET)，可以嵌套较为深的层级。在创建一张表的时候，需要指定一个基本类型的属性值作为 PK，可以再指定一个基本类型的属性值作为 SK。PK 的作用是将数据分散到不同的分区(Partition)里，构建无序的哈希索引，SK的作用是将同一个分区中的数据按照一定的顺序排列起来，便于查找。SK 中可以使用 ==, <, >=, <=, begins with, between, contains, in 等函数来进行较为丰富的查询操作，PK 必须使用准备的值进行查询。

## 与 SQL 的 异同
| SQL |  	NoSQLj |  
| :------------- | :----------: |
| Optimized for storage | Optimized for compute |
|Normalized/relational | Denormalized/Hierarchical |
| Ad hoc queries | Instantiated view |
| Scale vertically | Scale horizontally |
| Good for OLAP | Built for OLTP at scale |

SQL 是 **为存储进行优化** 的，通过存储范式化的数据，尽量减少了存储空间的使用，同时构建了非常强大的查询能力，可以通过新建不同的表对数据库容量进行扩张，适用于 OLAP 应用。

DynamoDB 是一种 NoSQL 的数据库针， 对 **计算资源进行了优化** ，以存储空间换计算时间。数据表中直接存储了非范式化的数据，可以直接拿出来使用。其中数据可以进行水平扩张，建表时无需指定确定的表结构，适用于 OLTP 应用。

## 索引
DynamoDB 共有两种索引，一种是本地二级索引(Local Secondary Index，简称 **LSI**)，一种是全局二级索引(Global Secondary Index，简称 **GSI**)

### 本地二级索引 (LSI)
本地二级索引和原表共用一份 Partition, 使用同一个 PK, 共用这一个 PK 的存储空间，上限为 10GB。LSI 提供了不同的筛选方式和排序方式，选用不同的属性作为 SK 可以提高查询的灵活性。

### 全局二级索引 (GSI)
全局二级索引几乎相当于一个全新的表，除了与原表共用同一个表名之外，GSI 使用了新的 Partition Key 和 Sort Key, 有自己独立的 Partition, 计算读写数量时也与原表相互独立。GSI 会在原表发生改变的时候，通过流(Stream)将更新同步到 GSI 中。一个表可以建立 20 个全局二级索引。**推荐使用全局二级索引**，避免本地二级索引引起的读写容量的竞争，同时可以重新定义 PK 和 SK，支持更多的查询模式

### 读一致性
DynamoDB 由于是数据库云服务出身，因此在设计中着重考虑了数据的 **可用性**和**分区容忍性**。从 CAP(Consistency, Availability, Partitioning)理论的角度来讲，DynamoDB 是一个 AP 的数据库。

在 DynamoDB 中，共有两个部分会涉及到读一致性的问题：主表读和GSI读。

主表读过程会产生一致性问题的原因是 DynamoDB 的 Partition 是有**三个副本**的（实际为可用区，详细内容可查询“AWS区域和终端节点及可用区”），默认情况下写入到两个副本中即认为写入成功，因此在高频读取时也有一定的概率读到未完成写入的数据。可以通过配置 GetItem, Scan 等的操作一致性为**强一致性**来避免这个问题，但可能会带来更高的延迟（10ms级别）和吞吐量开销（强一致性为最终一致性吞吐量开销的二倍）。

GSI 读写会产生一致性的原因是 GSI 和主表实际是**两个不同的存储**，写入到主表的数据会通过流同步到GSI，这个过程会存在一定的延时（10ms级别），因此在读取 GSI 中的数据时，**不能设置为强一致性**。

### 表结构设计
对于关系型数据库来说，我们只需要将数据模型范式化之后，分别建表，在查询时使用 SQL 进行关联即可实现不同的查询方式，更适合于查询方式复杂多变的系统。 而 DynamoDB 是需要提前考虑好一些查询方式，才能更好的设计表结构，否则可能会在使用的过程中遇到一些不便。

DynamoDB 限于底层结构设计，进行表扫描(Scan)的操作非常耗时，对于较大的表来说基本上是**不可接受**的时间消耗，因此需要根据 DynamoDB 的特点对表结构进行巧妙的设计，以实现需要的查询组合。因此，设计 DynamoDB 的第一步便是列举出可能的查询方式。当我们有了一组查询方式之后，便可以开始进行表结构的设计。

### 基本查询
在设计出查询方式之后，便可以优先关注使用量最多，查询方式最简单的查询需要。以下为主表中几种常见的查询方式：

1. 使用 PK 直接查询。可以查出该分区键下的所有数据，适合于 **一对多关系**。例如查询一个用户下的多个订单记录，这时 PK 为用户的 ID
2. 使用 PK + 完整 SK 进行查询。如果一个 PK 下的数据比较多，可以结合 SK 来实现更为精确的查询。例如查询一个用户下的一个特定的订单，这时 PK 为用户的 ID，SK 为订单的ID。
3. 使用 PK + SK (==, <, >=, <=, begins with, between, contains, in) 进行查询。如果一个 PK 下数据比较多，同时每一类 SK 上有通用的前缀，可以用 begins with 来进行查询。例如查询用户的订单使用用户 ID 和 SK 前缀 order: 进行查询。

### 索引重载
索引重载是使用 RDS 的用户最容易感到不适应的一部分，这意味着属性名不一定是一个有实际含义的名称，其内容也可能包含多个种类。AWS 的 Principal Technologist, Rick Houlihan 曾说，一个设计良好的 DynamoDB 应该只有一张表。这显然与我们对 RDS 数据的认识完全不一样，RDS 倾向于细粒度的划分每个实体，为实体及实体之间的关系建立相关的表。如果说我们一个应用只有一张表，那么意味着用户、订单、商品、发票等数据会共用一个表定义，表的结构可能类似下面这个样子：

| PK|  SK(GSI-PK) | DATA(GSI-SK) | DATA1 | DATA2 | 
| :------------- | :----------: |:----------: |:----------: |:----------: |
| 用户ID | profile | xx| xx |xx |
| 用户ID | 	order-1 | yy | xx| xx|
| 用户ID | 	order-2 | zz | xx|xx |
| 用户ID | 	invoice-1 | vv|xx |xx |
| 商品ID | detail |	xx | xx|xx |

可以使用 #User#{ID} 和 #PRODUCT#{ID}这样的方式在 ID 中带上该条记录的类型，SK 也可以采用类似的设计方式，这样一方面我们的可以更好的辨识一条数据的类型，另一方面当 PK 在 GSI 中作为 SK 时，可以使用 begins with 查出同一类的数据。

因为 DynamoDB 可以自动扩容，所设计好这一个表之后，我们便可以方便的对该表创建 GSI，开启备份，使用同样的查询、数据插入的命令来完成各种各样的操作，同时因为使用同一个读写容量，所以会减少读写容量的浪费。新建不同的表来存储这些内容，其实新建的表与该表也不会太大的差异，使用同一张表反而更加方便。

在使用 PK 和 SK 进行 Query 之后，还可以使用 Filter 进行数据的筛选，这些筛选只能使用在基础数据类型上面，因此如果存储 list, map, set 时可能会简化一些操作，但在筛选时遇到一些问题。这种时候就可以利用 sk 的 begins with 查询功能，将数据拆分开来方便筛选。

### 稀疏索引 等其他
https://www.jianshu.com/p/70ae83442584